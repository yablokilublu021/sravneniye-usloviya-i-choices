# sravneniye-usloviya-i-choices

Сравнение
Два числа можно сравнить при помощи операторов сравнения:

== равенство (a == b)
!= неравенство (a != b)
>= больше или равно (a >= b)
<= меньше или равно (a <= b)
> больше (a > b)
< меньше (a < b)
В рассмотренных выше абстрактных примерах с a и b мы получаем логическое значение, которое является результатом сравнения чисел. Пусть a = 10 и b = 20, тогда скобка (a > b) вернёт значение false, потому что a меньше b. А вот (a != b) вернёт true, т.к. а действительно не равно b.
>
>true/false и 1/0
Для программы ключевое слово true это 1, а false это 0, и их можно равноценно друг на друга заменять. Зачем тогда их придумали, если можно использовать 1 и 0 и получить более короткую запись? Эти обозначения нужны в первую очередь для удобства программиста, чтобы в большой программе сориентироваться по типам данных, т.к. true и false принято присваивать только к логическим переменным типа bool. Например, если в коде встретится var = 0; - то var может быть любым численным типом данных, а если var = false; - то мы сразу понимаем, что это флаг, и это понимание помогает быстрее сориентироваться в чужом и своём коде.

Условный оператор if
Условный оператор if (англ. "если") позволяет разветвлять выполнение программы в зависимости от логических величин, т.е. результатов работы операторов сравнения и логических переменных.

Особенность bool
В уроке о типах данных я упоминал о том, что bool принимает значение true, если присвоить ему отличное от нуля число, то есть оператору if можно скормить любое число, и он вернёт true в любом случае, кроме нуля. Это бывает удобно в некоторых случаях, но также может и приводить к ошибкам, которые трудно отловить. if (50) {} - код в фигурных скобках будет выполнен.

Порядок условий
Порядок условий играет очень большую роль: логические выражения и переменные проверяются слева направо, и если результат всего выражения в скобках будет однозначно определён после проверки первого выражения - остальные выражения проверяться не будут. Например если в выражении if (a && b && c) хотя бы а имеет значение false, проверка остальных выражений (b и c) уже не выполняется, потому что всё выражение заведомо будет false.

Или наоборот: если в выражении if (a || b || c) хотя бы а будет true - всё выражение также будет true и b с c не будут проверяться.

Это может помочь в оптимизации кода: например, есть какой-то флаг и выражение, которое вычисляется прямо в условии и сразу проверяется. Если флаг опущен, микроконтроллер не будет тратить время на лишние вычисления и сразу покинет

